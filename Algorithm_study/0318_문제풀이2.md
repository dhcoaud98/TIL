# 03.18

## 알고리즘 문제풀이2

<br>

1. **Itertools.permutations(iterable, r)**

   반복이 가능한 객체에 대해서 중복을 허용하지 않고 r개를 뽑아서 나열

   ```python
   from itertools import permutations
   
   data = ['a', 'b', 'c', 'd']
   y = permutations(data, 2)
   
   
   ```python
   from itertools import permutations
   
   data = ['A', 'B', 'C', 'D']
   
   y = permutations(data, 개수)
   
   
   """
   => [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'A'), ('B', 'C'), ('B', 'D'), ('C', 'A'), ('C', 'B'), ('C', 'D'), ('D', 'A'), ('D', 'B'), ('D', 'C')]
   
   print(list(map(''.join, y)))
   => ['AB', 'AC', 'AD', 'BA', 'BC', 'BD', 'CA', 'CB', 'CD', 'DA', 'DB', 'DC']
   """
   
   """
   # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
   # permutations(range(3)) --> 012 021 102 120 201 210
   """
   
   ```

2. **BFS**문제풀기

   **조건**이 붙게 되면 조금 더 어렵다. 시간초과나 횟수에 제한이 있는 경우 이 경우도 생각해주어야 하기 때문이다. 다음과 같이 `visited`의 값을 다르게 조정해서 결과를 쉽게 도출할 수 있다. 

   ```python
   ...
   visited[now_y][now_x] = visited[j][i] + 1
   ...
   ```

   후에 거리 `L` 만큼만 구하기 위해선

   ```python
   ...
   visited[now_y][now_x] = visited[j][i] + 1
   if visited[now_y][now_x] == L+1:
       break
   ...
   ```

   
