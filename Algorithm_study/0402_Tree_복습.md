# 04.01

## 트리

<br>

[TOC]

<br>

### 1. Tree

* 트리는 루트부터 시작해서 나무가지가 뻗어나가는 형태로 구현되는 자료 구조다. Graph 자료구조의 한 형태로 싸이클이 없어야 한다. 

  Node(노드), Edge(간선), root(트리가 시작되는 지점), Level, Parent&Child, Degree(차수), Leaves of External Nodes(외부노드, 자식 노드가 없는 가장 말단에 있는 노드), Height(높이)

1. Binary Tree(이진트리)

   이진 트리란 어떤 부모 노드가 가질 수 있는 자식의 최대 수가 2개인 트리를 말한다. 완전 이진 트리는 N개의 노드가 빈 자리 없이 채워진 상태를 말하는 것이지, 노드의 키 값이 순차적으로 증가하는 것은 아니다. 





<br>

### 2. Heaps

* 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조
* 힙은 트리의 한 종류이며, 증가 또는 감소하는 형태로 정렬된 트리를 힙이라고 부른다. 이런 성질 때문에 루트 노드는 항상 최대 또는 최소 값이 된다. 
* Max Heaps(최대 힙) : 부모가 항상 자식보다 값이 커야하는 트리. 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리이다. 
* Min Heaps(최소 힙) : 부모가 항상 자식보다 값이 작아야하는 트리. 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리이다. 

1. **Max Binary Heap** 

   바이너리 힙은 무조건 `완전 이진트리`여야 한다. 새로운 노드가 추가될 때 마지막 레벨에서 왼쪽부터 오른쪽 순으로 채워짐을 뜻한다. 루트 노드는 항상 트리에서 최대값을 반환하는데 따라서 O(1)의 시간으로 최대값을 뽑아낼 수 있다. 힙에서 원하는 값을 찾을 때는 항상 루트 노드가 자식 노드보다 값이 크다는 성질을 이용하는데 이때 평균 시간 복잡도는 O(N/2)이지만 결국 O(N)으로 근사화된다. 

2. **Heapify**

   히퍼파이는 힙에서 전체 트리를 재정렬 하는 과정을 뜻한다. 요소를 추가하거나 꺼낼 때 이용된다. 

   * Insert(삽입) : 새로운 요소를 추가할 때는 BST에서 사용했던 방식을 이용한다. 

     ```tex
     1. 빈 자리를 찾아서 일단 새로운 요소를 집어 넣는다. 
     2. 재정렬(heapify)을 진행한다. 
     3. 맥스 힙이라면 새로 추가된 노드가 부모보다 큰 값인지 비교하여 정렬하면 된다. 
     ```

   * Delete(꺼내기) : 힙에서 값을 빼낼 때는 보통 루트 노드의 값을 빼낸다고 가정한다.(힙을 사용하는 이유 이므로) 

     ```tex
     1. 루트 노드의 값을 제거한다. 루트자리가 비게 되므로 가장 오른쪽에 있는 리프를 일단 가져온다. 
     2. 새로운 루트 노드가 힙의 조건을 만족하는지 체크하기 위해 재정렬(heapify)을 진행한다. 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다. 
     ```

3. **Heap Implementation**

   비록 힙이 트리로 대표되는 자료구조이지만 보통 사용할 때는 **배열을 이용해서 사용한다.** 배열을 오름차순 혹은 내림차순 정렬을 한 후 이진 트리에 차례로 넣어주면 된다. 배열을 이용해서 힙을 생성하는 방식이 클래스를 이용하는 방식보다 더 편하다. 배열을 이용하면 각 노드의 값과 배열에 저장될 인덱스만 알면 되기 때문이다. 

   ```python
   N = 6
   data = [3, 6, 2, 1, 7, 9]
   
   tree = [0 for _ in range(N + 1)]
   last = 1
   
   for i in range(len(data)):
       if not tree[i]:
           tree[last] = data[i]
       else:
           last += 1
           child = last  # 새로 추가된 정점을 자식으로
           parent = child // 2  # 완전 이진트리에서의 부모 정점 번호
   
           tree[child] = data[i]
           # print(tree, child, parent)
           """
           # 삽입 및 정렬 순서
           # tree / child_idx / parent_idx
           [0, 3, 6, 0, 0, 0, 0] 2 1
           [0, 3, 6, 2, 0, 0, 0] 3 1
           [0, 2, 6, 3, 1, 0, 0] 4 2
           [0, 1, 2, 3, 6, 7, 0] 5 2
           [0, 1, 2, 3, 6, 7, 9] 6 3
           """
           # 부모가 있고, 부모가 자식보다 큰 동안(부모가 작아질 때 까지)
           while parent >= 1 and tree[parent] > tree[child]:
               # 부모와 자식 위치 변경
               tree[parent], tree[child] = tree[child], tree[parent]
               # 자식 위치를 부모로 변경
               child = parent
               # 부모는 부모 // 2 => 조상 노드
               parent = parent // 2
       # print(tree)
   print(tree)
   
   
   """
   output 
   [0, 1, 2, 3, 6, 7, 9]
   """
   ```

   

    
