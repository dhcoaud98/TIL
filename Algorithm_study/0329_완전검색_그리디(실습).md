# 03.29

## 완전검색/그리디

<br>

[TOC]

<br>

### 1. lambda 사용

```python
arr = [list(map(int, input().split())) for _ in range(N)]
# arr = [[14, 23], [2, 19], [1, 22], [12, 24], [21, 23], [6, 15], [20, 24], [1, 4], [6, 15], [15, 16]]
    
arr = sorted(arr, key=lambda x: (x[1]))  # 종료시점을 기준으로 정렬
# arr = [[1, 4], [6, 15], [6, 15], [15, 16], [2, 19], [1, 22], [14, 23], [21, 23], [12, 24], [20, 24]]
```

arr를 오름차순으로 정렬하는데, 어떤 기준으로? 이차원 배열 안의 list 값 중 인덱스= 1인 값을 기준으로!

`key=lambda x: (x[1])`

https://docs.python.org/ko/3/howto/sorting.html

<br>

<br>

### 2. 다익스트라 알고리즘

경로를 찾는 알고리즘은 DFS, DFS, 백트래킹 등 많은 방법이 있다. 그러나 이 방법은 배열의 크기가 커질 수록 메모리가 늘어나고, 런타임에 걸릴 수 있다. 따라서 **다익스트라(dijkstra)** 알고리즘을 사용한다. 다익스트라 알고리즘은 하나의 시작 정점으로 부터 다른 정점까지의 최단 경로를 찾는 _최단경로 알고리즘_이다.

1. 시작점은 1이라고 가정하고, 표에서 1은 0, 나머지는 inf(python)에서 가장 큰 값

![image-20220329234406624](0329_완전검색_그리디(실습).assets/image-20220329234406624.png)

2. 시작지점인 1을 기점으로 갈 수 있는 노드들의 거리를 표에 갱신해준다.

   ![image-20220329235758301](0329_완전검색_그리디(실습).assets/image-20220329235758301.png)

3. 시작노드인 1번을 방문 처리하고, 1번 노드의 인접노드들 중 방문하지 않은 노드들(여기에서는 2, 3, 4번 노드가 후보) 중 시작 노드인 1번 노드와 가장 최단 거리인 4번 노드를다음에 탐색할 노드로 선택한다.

   ![image-20220329235923697](0329_완전검색_그리디(실습).assets/image-20220329235923697.png)

1과 연결된 노드들 중 가장 작은 값은 4번 노드이므로 4번 노드에서 탐색을 시작한다. 4번 노드는 3번, 5번과 간선으로 연결되어 있다. 우선 3번에 대해 탐색하면 `min(5,1+3)`이라고 되어 있다. 

* min(5, 1+3)

  * 5 : 2단계에서 갱신했던 시작노드 1번에서 3번 노드로 다이렉트로 한 번에 갈 수 있는 거리
  * 1+3 : 1번에서 4번 노드로 가는 거리비용 + 4번에서 3으로 가는 거리비용 

  둘 중 최솟값으로 노드번호 3으로 가는 거리를 갱신해준다. 

4. 2번 노드도 똑같은 방법으로 해주는데, 2번 노드에서 열결되어 있는 노드인 3, 4의 값을 갱신해 준다. 

   ![image-20220330001601866](0329_완전검색_그리디(실습).assets/image-20220330001601866.png)

:seedling: 결국, 다익스트라 알고리즘은 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정을 반복하는 것이 핵심이다. 각 단계마다 탐색 노드로 한번 선택된 노드는 최단 거리가 갱신되고 난 후 재 갱신 되지 않는 것을 알 수 있다. 
