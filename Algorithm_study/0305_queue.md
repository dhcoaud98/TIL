# 03.05

## Queue

<br>

### 선형큐

큐(Queue)는 스택과 비슷하게 삽입과 삭제의 위치가 제한적인 자료구조이다. 가장 큰 특징은 뒤에서 삽입하고, 앞에서는 삭제만 이루어지는 구조이다. (FIFO : First In First Out)

* 삽입 : enQueue(item)

* 삭제 : deQueue()

* 공백의 큐를 생성 : createQueue()

* 큐가 공백상태인지 : isEmpty()

* 큐가 포화상태인지 : isFull()

* 큐 앞(front)에서 원소를 삭제 없이 반환하는 연산 : Qpeek() 

  스택의 pop()과 비슷하다. 

큐는 `front`와 `rear`를 통해서 연산할 수 있다. `front = rear = -1`에서 시작한다. 

|     초기 상태     |   공백 상태   |  포화 상태  |
| :---------------: | :-----------: | :---------: |
| front = rear = -1 | front == rear | rear == n-1 |

:red_circle: 선형 큐 이용시 잘못된 포화상태 인식으로 인해 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고, rear=n-1 인 상태 즉, 포화 상태로 인식하여 더 이상 삽입을 할 수 없게 된다. 

​	<해결방법 1>

* 매 연산이 이루어 질 때마다 저장된 원소들을 배열의 앞으로 모두 이동시킨다. 이 경우 원소 이동에 시간이 소요되어 큐의 효율성이 급격히 떨어진다.

​	<해결방법 2>

* 원형큐를 사용한다. 

<br>

### 원형큐

|    초기 상태     |   공백 상태   | 포화 되었다고 보는 상태 |
| :--------------: | :-----------: | :---------------------: |
| front = rear = 0 | front == rear | rear == n-1, front = 1  |

즉, 삽입할 rear의 다음 위치 == 현재 front인 경우에 포화상태라고 할 수 있다. 

* `(rear + 1) % n == front` 

front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동한다. 이를 위해 나머지 연산자 **mod**를 사용한다. 

공백과 포화를 구분하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 두어야 한다. 

|        |       삽입 위치       |        삭제 위치        |
| :----: | :-------------------: | :---------------------: |
| 선형큐 |    rear = rear + 1    |    front = front + 1    |
| 원형큐 | rear = (rear + 1) % n | front = (front + 1) % n |

<br>

### 우선순위 큐(Priority Queue)

FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다. 

* 배열을 이용한 우선순위 큐

  : 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입한다. 가장 앞에 최고 우선순위의 원소가 위치하게 된다. 배열을 사용하기 때문에 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생한다. 이에 소요되는 시간과 메모리 낭비가 크다. 

* 리스트를 이용한 우선순위 큐

<br>

### 버퍼(Buffer)

데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역이다. 버퍼를 활용하는 방식 혹은 버퍼를 채우는 동작을 버퍼링이라고 한다. 순서대로 입력과 출력, 전달이 이루어져야 하기 때문에 FIFO 방식의 자료구조인 큐가 사용된다. 

<br>

### BFS(Breadth First Search)

:star2: 너비 우선 탐색이라고 한다. 이는 담색 시작점의 인접한 정점을 큐의 뒤쪽으로 넣어 탐색하는 방식이다. 한 점에 방문했을 경우 이 점과 인접해 있는 모든 정점들을 큐에 뒤쪽에 삽입하게 되고, 현재 탐색하는 순서는 큐의 앞에부터 순차적으로 이루어지기 때문에 큐를 사용하게 되는 것이다. 

```python
def BFS(G,v):  # G는 그래프(딕셔너리 형태임), v는 탐색의 시작지점
    visited = [0]*(n+1)
    queue = []
    queue.append(v)
    while queue :  # queue가 비어있다면 종료
        t = queue.pop(0)  # 현재 queue의 첫번째 원소를 t에 넣음.
        # print(t)
        if not visited[t] :  # t에 아직 방문하지 않았다면
            visited[t] = True  # 방문 표시를 남기고
            visit(t)  # visit라는 또 다른 함수에서 할일 하기
        for i in G[t] :  # t와 연결된 모든 정점에서
            if not visited[i]  # 연결된 모든 정점이 방문되지 않았다면
            	queue.append(i)  # 큐에 넣고 while문을 반복한다.
```

